// Generated by CoffeeScript 1.6.1
/*
Copyright (c) 2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

describe('Deft.promise.Promise', function() {
  var formatValue;
  formatValue = function(value) {
    var formattedValues;
    if (value instanceof Deft.promise.Promise) {
      return 'Deft.Promise';
    }
    if (value instanceof Deft.promise.Deferred) {
      return 'Deft.Deferred';
    }
    if (value instanceof Ext.ClassManager.get('Ext.Base')) {
      return Ext.ClassManager.getName(value);
    }
    if (Ext.isArray(value)) {
      formattedValues = Ext.Array.map(value, formatValue);
      return "[" + (formattedValues.join(', ')) + "]";
    }
    if (Ext.isObject(value)) {
      return 'Object';
    }
    if (Ext.isString(value)) {
      return "\"" + value + "\"";
    }
    return '' + value;
  };
  chai.use(function(chai, utils) {
    Assertion.addMethod('memberOf', function(array) {
      var value;
      value = utils.flag(this, 'object');
      this.assert(Ext.Array.contains(array, value), 'expected #{this} to be a member of ' + utils.inspect(array), 'expected #{this} to not be a member of ' + +utils.inspect(array));
    });
    Assertion.addMethod('membersOf', function(array) {
      var values;
      values = utils.flag(this, 'object');
      expect(values).to.be.an.Array;
      this.assert(Ext.Array.filter(values, function(value) {
        return !Ext.Array.contains(array, value);
      }).length === 0, 'expected #{this} to be members of ' + utils.inspect(array), 'expected #{this} to not be members of ' + +utils.inspect(array));
    });
    Assertion.addProperty('unique', function() {
      var values;
      values = utils.flag(this, 'object');
      expect(values).to.be.an.instanceOf(Array);
      this.assert(Ext.Array.unique(values).length === values.length, 'expected #{this} to be comprised of unique values', 'expected #{this} not to be comprised of unique values');
    });
  });
  describe('Custom Assertions', function() {
    specify('memberOf', function() {
      expect(1).to.be.memberOf([1, 2, 3]);
      expect(0).not.to.be.memberOf([1, 2, 3]);
    });
    specify('membersOf', function() {
      expect([1]).to.be.membersOf([1, 2, 3]);
      expect([1, 2]).to.be.membersOf([1, 2, 3]);
      expect([0]).not.to.be.membersOf([1, 2, 3]);
      expect([0, 5]).not.to.be.membersOf([1, 2, 3]);
    });
    specify('unique', function() {
      expect([1, 2, 3]).to.be.unique;
      expect([1, 2, 1]).not.to.be.unique;
    });
  });
  describe('when()', function() {
    var values;
    values = [void 0, null, false, 0, 1, 'expected value', [1, 2, 3], {}, new Error('error message')];
    describe('returns a Promise that will resolve with the specified value', function() {
      var value, _fn, _i, _len;
      _fn = function(value) {
        return specify(formatValue(value), function() {
          var promise;
          promise = Deft.Promise.when(value);
          promise.should.be.an["instanceof"](Deft.Promise);
          return promise.should.eventually.equal(value);
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
    describe('returns a Promise that will resolve with the resolved value for the specified Promise when it resolves', function() {
      var value, _fn, _i, _len;
      _fn = function(value) {
        return specify(formatValue(value), function() {
          var deferred, promise;
          deferred = Ext.create('Deft.Deferred');
          deferred.resolve(value);
          promise = Deft.Promise.when(deferred.promise);
          promise.should.not.be.equal(deferred.promise);
          promise.should.be.an["instanceof"](Deft.Promise);
          return promise.should.eventually.equal(value);
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
    describe('returns a Promise that will reject with the error associated with the specified Promise when it rejects', function() {
      specify('Error: error message', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.Deferred');
        deferred.reject(new Error('error message'));
        promise = Deft.Promise.when(deferred.promise);
        promise.should.not.be.equal(deferred.promise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will adapt the specified untrusted (aka third-party) then-able', function() {
      var MockThirdPartyPromise;
      MockThirdPartyPromise = (function() {

        function MockThirdPartyPromise() {}

        MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
          this.successCallback = successCallback;
          this.failureCallback = failureCallback;
          switch (this.state) {
            case 'resolved':
              this.successCallback(this.value);
              break;
            case 'rejected':
              this.failureCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.resolve = function(value) {
          this.value = value;
          this.state = 'resolved';
          if (this.successCallback != null) {
            this.successCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.reject = function(value) {
          this.value = value;
          this.state = 'rejected';
          if (this.failureCallback != null) {
            this.failureCallback(this.value);
          }
        };

        return MockThirdPartyPromise;

      })();
      specify('resolves when resolved', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('rejects when rejected', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
  });
  describe('isPromise()', function() {
    describe('returns true for a Deft.Promise', function() {
      specify('Deft.Promise', function() {
        var promise;
        promise = Ext.create('Deft.Deferred').promise;
        expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
      specify('returns true for any then()-able', function() {
        var promise;
        promise = {
          then: function() {}
        };
        expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
    });
    return describe('returns false for non-promises', function() {
      var value, values, _fn, _i, _len;
      values = [void 0, null, false, 0, 1, 'value', [1, 2, 3], {}, new Error('error message')];
      _fn = function(value) {
        return specify(formatValue(value), function() {
          expect(Deft.Promise.isPromise(value)).to.be["false"];
        });
      };
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _fn(value);
      }
    });
  });
  describe('all()', function() {
    describe('returns a new Promise that will resolve with the resolved values for the specified Array of Promises(s) or values.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.all([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.all(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.all([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.all([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will resolve with the resolved values for the specified resolved Promise of an Array of Promises(s) or values.', function() {
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.reject(new Error('error message'))]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.all();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.all(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.all(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('any()', function() {
    describe('returns a new Promise that will resolve once any one of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.any(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.any([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.any([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([2, 4, 5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2]);
      });
    });
    describe('returns a new Promise that will resolve once any one of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([2, 4, 5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.to.be.a.memberOf([1, 2, 3]);
      });
      specify('Promise of an Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise of an Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.be.a.memberOf([1, 2]);
      });
    });
    describe('returns a new Promise that will reject if none of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.any([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array of rejected Promises', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject if none of the specified resolved Promise of an Array of Promises(s) or values resolves.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
      specify('Array of rejected Promises', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'No Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.any();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.any(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.any(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('some()', function() {
    describe('returns a new Promise that will resolve once the specified number of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.some(['expected value'], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.some([1, 2, 3], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.some([,2,,4,5], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([2, 4, 5]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.resolve('expected value')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
      specify('Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
    });
    describe('returns a new Promise that will resolve once the specified number of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when(['expected value']), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([1, 2, 3]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([,2,,4,5]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([2, 4, 5]);
      });
      specify('Promise of an Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.resolve('expected value')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2, 3]);
      });
      specify('Promise of an Array of rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of pending and rejected Promises and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Deft.Deferred.reject('error message'), Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
      specify('Promise of an Array of pending and rejected Promises and multiple resolved Promises', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Promise.when([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve(1), Deft.Deferred.reject('error message'), Deft.Deferred.resolve(2)]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.have.a.lengthOf(2).and.be.membersOf([1, 2]);
      });
    });
    describe('returns a new Promise that will reject if too few of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some([], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Empty Array with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some([], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message')], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')], 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')], 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject if too few of the specified resolved Promise of an Array of Promises(s) or values resolves.', function() {
      specify('Empty Array with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Empty Array with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array with one rejected Promise with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message')]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with one resolved value requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]), 1);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
      specify('Array of rejected Promises with multiple resolved values requested', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Too few Promises were resolved.');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.some(Deft.Deferred.reject(new Error('error message')), 2);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        expect(function() {
          return Deft.Promise.some();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        expect(function() {
          return Deft.Promise.some(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('multiple non-Array parameters', function() {
        expect(function() {
          return Deft.Promise.some(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single Array parameter', function() {
        expect(function() {
          return Deft.Promise.some([1, 2, 3]);
        }).to["throw"](Error, 'Invalid parameter: expected a positive integer.');
      });
      specify('a single Array parameter and a non-numeric value', function() {
        expect(function() {
          return Deft.Promise.some([1, 2, 3], 'value');
        }).to["throw"](Error, 'Invalid parameter: expected a positive integer.');
      });
    });
  });
  describe('delay()', function() {
    var now;
    now = function() {
      return new Date().getTime();
    };
    describe('should return a new Promise that will resolve after the specified delay', function() {
      specify('0 ms delay', function() {
        var promise;
        promise = Deft.Promise.delay(0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(void 0);
      });
      specify('value with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay(100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 10);
          return value;
        });
        return promise.should.eventually.equal(void 0);
      });
    });
    describe('should return a new Promise that will resolve with the specified Promise or value after the specified delay', function() {
      specify('value with 0 ms delay', function() {
        var promise;
        promise = Deft.Promise.delay('expected value', 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('resolved Promise with 0 delay', function() {
        var promise;
        promise = Deft.Promise.delay(Deft.Deferred.resolve('expected value'), 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('value with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay('expected value', 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 10);
          return value;
        });
        return promise.should.eventually.equal('expected value');
      });
      specify('resolved Promise with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay(Deft.Deferred.resolve('expected value'), 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          expect(now() - start).to.be.closeTo(100, 10);
          return value;
        });
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('should return a new Promise that will reject with the error associated with the specified rejected Promise after the specified delay', function() {
      specify('rejected Promise with 100 ms delay', function() {
        var promise, start;
        this.slow(250);
        promise = Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 100);
        start = now();
        promise.should.be.an["instanceof"](Deft.Promise);
        promise = promise.then(function(value) {
          return value;
        }, function(error) {
          expect(now() - start).to.be.closeTo(100, 10);
          throw error;
        });
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  describe('timeout()', function() {
    describe('should return a new Promise that will resolve with the specified Promise or value if it resolves before the specified timeout', function() {
      specify('value with 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout('expected value', 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Promise that resolves in 50 ms with a 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay('expected value', 50), 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('should return a new Promise that will reject with the error associated with the specified rejected Promise if it rejects before the specified timeout', function() {
      specify('Promise that rejects in 50 ms with a 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 50), 100);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('should return a new Promise that will reject after the specified timeout if the specified Promise or value has not yet resolved or rejected', function() {
      specify('Promise that resolves in 100 ms with a 50 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay('expected value', 100), 50);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Promise timed out.');
      });
      specify('Promise that rejects in 50 ms with a 100 ms timeout', function() {
        var promise;
        this.slow(250);
        promise = Deft.Promise.timeout(Deft.Promise.delay(Deft.Deferred.reject(new Error('error message')), 100), 50);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'Promise timed out.');
      });
    });
  });
  describe('memoize()', function() {
    var fibonacci;
    fibonacci = function(n) {
      if (n < 2) {
        return n;
      } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
      }
    };
    describe('should return a new function that wraps the specified function, caching results for previously processed inputs, and returns a Promise that will resolve with the result value', function() {
      specify('value', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = Deft.Promise.all([memoFunction(12), memoFunction(12)]).then(function(value) {
          expect(targetFunction).to.be.calledOnce;
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.deep.equal([fibonacci(12), fibonacci(12)]);
      });
      specify('resolved Promise', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = Deft.Promise.all([memoFunction(Deft.Deferred.resolve(12)), memoFunction(Deft.Deferred.resolve(12))]).then(function(value) {
          expect(targetFunction).to.be.calledOnce;
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.deep.equal([fibonacci(12), fibonacci(12)]);
      });
    });
    describe('should execute the wrapped function in the optionally specified scope', function() {
      specify('optional scope omitted', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = memoFunction(12).then(function(value) {
          expect(targetFunction).to.be.calledOnce.and.calledOn(void 0);
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.equal(fibonacci(12));
      });
      specify('scope specified', function() {
        var memoFunction, promise, targetFunction, targetScope;
        targetScope = {};
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction, targetScope);
        promise = memoFunction(12).then(function(value) {
          expect(targetFunction).to.be.calledOnce.and.calledOn(targetScope);
          return value;
        }, function(error) {
          throw error;
        });
        return promise.should.eventually.equal(fibonacci(12));
      });
    });
    describe('should return a new function that wraps the specified function and returns a Promise that will reject with the associated error when the wrapper function is called with a rejected Promise', function() {
      specify('rejected Promise', function() {
        var memoFunction, promise, targetFunction;
        targetFunction = sinon.spy(fibonacci);
        memoFunction = Deft.Promise.memoize(targetFunction);
        promise = memoFunction(Deft.Deferred.reject(new Error('error message')));
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  describe('map()', function() {
    var doubleFunction, doublePromiseFunction, rejectFunction;
    doubleFunction = function(value) {
      return value * 2;
    };
    doublePromiseFunction = function(value) {
      return Deft.Deferred.resolve(value * 2);
    };
    rejectFunction = function(value) {
      return Deft.Deferred.reject(new Error('error message'));
    };
    describe('returns a new Promise that will resolve with an Array of the mapped values for the specified Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.map([], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map([1], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, 3], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map([,2,,4,5], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the mapped values for the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.map([], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map([1], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, 3], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map([,2,,4,5], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will resolve with an Array of the resolved mapped Promises values for the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,4,,8,10]);
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2]);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6]);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), doublePromiseFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([2, 4, 6, 8]);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.reject(new Error('error message'))], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.reject(new Error('error message')), 3], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise], doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), 3]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map([1], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map([1, 2, 3], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map([,2,,4,5], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1)], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first mapped Promise value in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, 2, 3]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([,2,,4,5]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), rejectFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.map(Deft.Deferred.reject(new Error('error message')), doubleFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
  return describe('reduce()', function() {
    var rejectFunction, sumFunction;
    sumFunction = function(previousValue, currentValue, index, array) {
      return previousValue + currentValue;
    };
    rejectFunction = function(previousValue, currentValue, index, array) {
      return Deft.Deferred.reject(new Error('error message'));
    };
    describe('returns a Promise that will resolve with the value obtained by reducing the specified Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Empty Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([], sumFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one value and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3, 4], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Sparse Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Array with one resolve Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one resolve Promise and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Array of resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)], sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a Promise that will resolve with the value obtained by reducing the specified resolved Promise of an Array of Promise(s) or value(s) using the specified function and initial value', function() {
      specify('Empty Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([]), sumFunction, 0);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(0);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one value and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3, 4]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Sparse Array and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(21);
      });
      specify('Array with one resolve Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(1);
      });
      specify('Array with one resolve Promise and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(11);
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(6);
      });
      specify('Array of resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(16);
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(10);
      });
      specify('Array of values and resolved Promises and an initial value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), 3, Deft.Deferred.resolve(4)]), sumFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal(20);
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.reject(new Error('error message'))], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.reject(new Error('error message')), 3], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise], sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or value(s) that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with values and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), 3]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values, pending and resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(4), Ext.create('Deft.Deferred').promise]), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the rejected Promise of an Array of Promise(s) or value(s)', function() {
      specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.reject(new Error('error message')), sumFunction);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified Array of Promise(s) or value(s)', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce([1], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce([1, 2, 3], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce([,2,,4,5], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1)], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4], rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that will reject with the error associated with the first rejected Promise returned by the specified function for the the specified resolved Promise of an Array of Promise(s) or value(s)', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, 2, 3]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([,2,,4,5]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array with one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1)]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of values and resolved Promises', function() {
        var promise;
        promise = Deft.Promise.reduce(Deft.Deferred.resolve([1, Deft.Deferred.resolve(2), Deft.Deferred.resolve(3), 4]), rejectFunction, 10);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
  });
});
