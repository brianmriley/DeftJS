// Generated by CoffeeScript 1.6.1
/*
Copyright (c) 2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

describe('Deft.promise.Promise', function() {
  var formatValue;
  formatValue = function(value) {
    var formattedValues;
    if (value instanceof Deft.promise.Promise) {
      return 'Deft.Promise';
    }
    if (value instanceof Deft.promise.Deferred) {
      return 'Deft.Deferred';
    }
    if (value instanceof Ext.ClassManager.get('Ext.Base')) {
      return Ext.ClassManager.getName(value);
    }
    if (Ext.isArray(value)) {
      formattedValues = Ext.Array.map(value, formatValue);
      return "[" + (formattedValues.join(', ')) + "]";
    }
    if (Ext.isObject(value)) {
      return 'Object';
    }
    if (Ext.isString(value)) {
      return "\"" + value + "\"";
    }
    return '' + value;
  };
  describe('when()', function() {
    var values;
    values = [void 0, null, false, 0, 1, 'expected value', [1, 2, 3], {}, new Error('error message')];
    describe('returns a Promise that eventually resolves with the specified value', function() {
      var value, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _results.push((function(value) {
          return specify(formatValue(value), function() {
            var promise;
            promise = Deft.Promise.when(value);
            promise.should.be.an["instanceof"](Deft.Promise);
            return promise.should.eventually.equal(value);
          });
        })(value));
      }
      return _results;
    });
    describe('returns a Promise that eventually resolves when the specified Promise is resolved', function() {
      var value, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _results.push((function(value) {
          return specify(formatValue(value), function() {
            var deferred, promise;
            deferred = Ext.create('Deft.Deferred');
            deferred.resolve(value);
            promise = Deft.Promise.when(deferred.promise);
            promise.should.not.be.equal(deferred.promise);
            promise.should.be.an["instanceof"](Deft.Promise);
            return promise.should.eventually.equal(value);
          });
        })(value));
      }
      return _results;
    });
    describe('returns a Promise that eventually rejects when the specified Promise is rejected', function() {
      return specify('Error: error message', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.Deferred');
        deferred.reject(new Error('error message'));
        promise = Deft.Promise.when(deferred.promise);
        promise.should.not.be.equal(deferred.promise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('returns a new Promise that adapts the specified untrusted (aka third-party) then-able', function() {
      var MockThirdPartyPromise;
      MockThirdPartyPromise = (function() {

        function MockThirdPartyPromise() {}

        MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
          this.successCallback = successCallback;
          this.failureCallback = failureCallback;
          switch (this.state) {
            case 'resolved':
              this.successCallback(this.value);
              break;
            case 'rejected':
              this.failureCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.resolve = function(value) {
          this.value = value;
          this.state = 'resolved';
          if (this.successCallback != null) {
            this.successCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.reject = function(value) {
          this.value = value;
          this.state = 'rejected';
          if (this.failureCallback != null) {
            this.failureCallback(this.value);
          }
        };

        return MockThirdPartyPromise;

      })();
      specify('resolves when resolved', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      return specify('rejects when rejected', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
  });
  describe('isPromise()', function() {
    describe('returns true for a Deft.Promise', function() {
      specify('Deft.Promise', function() {
        var promise;
        promise = Ext.create('Deft.Deferred').promise;
        return expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
      return specify('returns true for any then()-able', function() {
        var promise;
        promise = {
          then: function() {}
        };
        return expect(Deft.Promise.isPromise(promise)).to.be["true"];
      });
    });
    return describe('returns false for non-promises', function() {
      var value, values, _i, _len, _results;
      values = [void 0, null, false, 0, 1, 'value', [1, 2, 3], {}, new Error('error message')];
      _results = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _results.push((function(value) {
          return specify(formatValue(value), function() {
            return expect(Deft.Promise.isPromise(value)).to.be["false"];
          });
        })(value));
      }
      return _results;
    });
  });
  describe('all()', function() {
    describe('returns a new Promise that resolves with the resolved values for the specified Array of Promises(s) or values.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.all([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.all(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.all([1, 2, 3]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.all([,2,,4,5]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Array with one resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      return specify('Array of resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that resolves with the resolved values for the specified resolved Promise of an Array of Promises(s) or values.', function() {
      specify('Promise of an empty Array', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([]);
      });
      specify('Promise of an Array with one value', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      specify('Promise of an Array of values', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([1, 2, 3]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
      specify('Promise of a sparse Array', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([,2,,4,5]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([,2,,4,5]);
      });
      specify('Promise of an Array with one resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal(['expected value']);
      });
      return specify('Promise of an Array of resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.resolve(2), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal([1, 2, 3]);
      });
    });
    describe('returns a new Promise that rejects with the error associated with the first Promise in the specified Array of Promise(s) or values that rejects', function() {
      specify('Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.reject(new Error('error message'))]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      return specify('Array of values, resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all([1, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that rejects with the error associated with the first Promise in the specified resolved Promise of an Array of Promise(s) or values that rejects', function() {
      specify('Promise of an Array with one rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.reject(new Error('error message'))]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      specify('Promise of an Array of resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([Deft.Deferred.resolve(1), Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
      return specify('Promise of an Array of values, resolved Promises and a rejected Promise', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.resolve([1, Deft.Deferred.reject(new Error('error message')), Deft.Deferred.resolve(3)]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('returns a new Promise that rejects with the error associated with the rejected Promise of an Array of Promise(s) or values', function() {
      return specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.all(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        return expect(function() {
          return Deft.Promise.all();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        return expect(function() {
          return Deft.Promise.all(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      return specify('multiple non-Array parameters', function() {
        return expect(function() {
          return Deft.Promise.all(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('any()', function() {
    describe('returns a new Promise that will resolve once any one of the specified Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.any(['expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.any(['expected value', 'expected value', 'expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.any([,'expected value',,'expected value','expected value']);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array with one resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal('expected value');
      });
      specify('Array of resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.resolve('expected value'), Deft.Deferred.resolve('expected value'), Deft.Deferred.resolve('expected value')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of rejected Promise(s) and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      return specify('Array of pending and rejected Promise(s) and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('returns a new Promise that will resolve once any one of the specified resolved Promise of an Array of Promises(s) or values have resolved.', function() {
      specify('Array with one value', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve(['expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of values', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve(['expected value', 'expected value', 'expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Sparse Array', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([,'expected value',,'expected value','expected value']));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array with one resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.deep.equal('expected value');
      });
      specify('Array of resolved Promise(s)', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.resolve('expected value'), Deft.Deferred.resolve('expected value'), Deft.Deferred.resolve('expected value')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      specify('Array of rejected Promise(s) and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Deft.Deferred.reject('error message'), Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
      return specify('Array of pending and rejected Promise(s) and one resolved Promise', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.resolve([Ext.create('Deft.Deferred').promise, Deft.Deferred.resolve('expected value'), Deft.Deferred.reject('error message')]));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.eventually.equal('expected value');
      });
    });
    describe('returns a new Promise that will reject if none of the specified Array of Promises(s) or values resolves.', function() {
      specify('Empty Array', function() {
        var promise;
        promise = Deft.Promise.any([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"]('No Promises were resolved.');
      });
      specify('Array with one rejected Promise(s)', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"]('No Promises were resolved.');
      });
      return specify('Array of rejected Promise(s)', function() {
        var promise;
        promise = Deft.Promise.any([Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message'), Deft.Deferred.reject('error message')]);
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"]('No Promises were resolved.');
      });
    });
    describe('returns a new Promise that rejects with the error associated with the rejected Promise of an Array of Promise(s) or values', function() {
      return specify('Error: error message', function() {
        var promise;
        promise = Deft.Promise.any(Deft.Deferred.reject(new Error('error message')));
        promise.should.be.an["instanceof"](Deft.Promise);
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('throws an Error if anything other than Array or Promise of an Array is specified', function() {
      specify('no parameters', function() {
        return expect(function() {
          return Deft.Promise.any();
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      specify('a single non-Array parameter', function() {
        return expect(function() {
          return Deft.Promise.any(1);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
      return specify('multiple non-Array parameters', function() {
        return expect(function() {
          return Deft.Promise.any(1, 2, 3);
        }).to["throw"](Error, 'Invalid parameter: expected an Array or Promise of an Array.');
      });
    });
  });
  describe('some()', function() {});
  describe('delay()', function() {});
  describe('timeout()', function() {});
  describe('memoize()', function() {});
  describe('map()', function() {});
  return describe('reduce()', function() {});
});
