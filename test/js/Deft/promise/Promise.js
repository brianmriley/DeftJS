// Generated by CoffeeScript 1.6.1
/*
Copyright (c) 2013 [DeftJS Framework Contributors](http://deftjs.org)
Open source under the [MIT License](http://en.wikipedia.org/wiki/MIT_License).
*/

describe('Deft.promise.Promise', function() {
  var values;
  values = [void 0, null, false, 0, 1, 'expected value', [1, 2, 3], {}, new Error('error message')];
  describe('when()', function() {
    describe('returns a Promise that eventually resolves with the specified value', function() {
      var value, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _results.push((function(value) {
          return specify(value, function() {
            var promise;
            promise = Deft.Promise.when(value);
            promise.should.be.an["instanceof"](Deft.Promise);
            promise.should.not.be.fulfilled;
            promise.should.not.be.rejected;
            return promise.should.eventually.equal(value);
          });
        })(value));
      }
      return _results;
    });
    describe('returns a Promise that eventually resolves when the specified Promise is resolved', function() {
      var value, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = values.length; _i < _len; _i++) {
        value = values[_i];
        _results.push((function(value) {
          return specify(value, function() {
            var deferred, promise;
            deferred = Ext.create('Deft.Deferred');
            deferred.resolve(value);
            promise = Deft.Promise.when(deferred.promise);
            promise.should.be.an["instanceof"](Deft.Promise);
            promise.should.not.be.fulfilled;
            promise.should.not.be.rejected;
            return promise.should.eventually.equal(value);
          });
        })(value));
      }
      return _results;
    });
    describe('returns a Promise that eventually rejects when the specified Promise is rejected', function() {
      return specify('Error: error message', function() {
        var deferred, promise;
        deferred = Ext.create('Deft.Deferred');
        deferred.reject(new Error('error message'));
        promise = Deft.Promise.when(deferred.promise);
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.should.not.be.fulfilledled;
        promise.should.not.be.rejected;
        return promise.should.be.rejected["with"](Error, 'error message');
      });
    });
    return describe('returns a new Promise that adapts the specified untrusted (aka third-party) then-able', function() {
      var MockThirdPartyPromise;
      MockThirdPartyPromise = (function() {

        function MockThirdPartyPromise() {}

        MockThirdPartyPromise.prototype.then = function(successCallback, failureCallback) {
          this.successCallback = successCallback;
          this.failureCallback = failureCallback;
          switch (this.state) {
            case 'resolved':
              this.successCallback(this.value);
              break;
            case 'rejected':
              this.failureCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.resolve = function(value) {
          this.value = value;
          this.state = 'resolved';
          if (this.successCallback != null) {
            this.successCallback(this.value);
          }
        };

        MockThirdPartyPromise.prototype.reject = function(value) {
          this.value = value;
          this.state = 'rejected';
          if (this.failureCallback != null) {
            this.failureCallback(this.value);
          }
        };

        return MockThirdPartyPromise;

      })();
      specify('resolves', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.should.not.be.fulfilled;
        promise.should.not.be.rejected;
        return promise.should.eventually.equal('expected value');
      });
      return specify('rejects', function() {
        var mockThirdPartyPromise, promise;
        mockThirdPartyPromise = new MockThirdPartyPromise();
        mockThirdPartyPromise.resolve('expected value');
        promise = Deft.Promise.when(mockThirdPartyPromise);
        promise.should.not.be.equal(mockThirdPartyPromise);
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.should.not.be.fulfilled;
        promise.should.not.be.rejected;
        return promise.should.eventually.equal('expected value');
      });
    });
  });
  return describe('all()', function() {
    return describe('returns a new Promise that will only resolve once all the specified Promises(s) or values have resolved.', function() {
      return specify('[]', function() {
        var promise;
        promise = Deft.Promise.all([]);
        promise.should.be.an["instanceof"](Deft.Promise);
        promise.should.not.be.fulfilled;
        promise.should.not.be.rejected;
        return promise.should.eventually.deep.equal([]);
      });
    });
  });
});
